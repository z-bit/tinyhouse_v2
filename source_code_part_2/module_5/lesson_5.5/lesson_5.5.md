# X-CSRF Token

Currently, our log-in via cookie functionality works as intended since a viewer can log-in when a cookie is available in the browser. When we set the cookie on the server, we added some options to help ensure the cookie can only be sent through HTTPS. We also used the `sameSite` cookie option to state that the cookie can only be sent from the site a user is currently viewing which helps prevent [Cross-Site Request Forgery](https://developer.mozilla.org/en-US/docs/Glossary/CSRF) attacks.

In this lesson, we’ll take an additional step to prevent Cross-Site Request Forgery attacks and look to see how we can have the client pass an `X-CSRF` token with every request. In certain cases when needed, the server will use the token to verify the identity of the request, or in other words, verify that the request is coming from a viewer from the TinyHouse app (and not somewhere else).

This `authorize()` function will be used when we start to build functionality in our app that is to only be used or accessed by a viewer that's logged in to the application. When a request is to be made for some sensitive data, for example, if the viewer is trying to see their income - we'll want to verify that the viewer is requesting their own data.

This will make a little more sense as we set this up and start to use this in the next coming lessons.

### `authorize()`

In the server, we'll introduce a function called `authorize()` that will accept a token given to it and return a user document from the `users` collection that it finds based on two things.

1.  The viewer id from the client cookie.
2.  The autogenerated token from a viewer when a viewer signs in.

If we recall, we autogenerate a `token` and store it in the `users` collection when a user signs in. We autogenerate this token at the beginning of our `logIn()` resolver function.

```ts
        const token = crypto.randomBytes(16).toString("hex");
```

When a user is to ever sign-in again, with Google Sign-In or with a cookie, we re-generate this token. The `authorize()` function we'll create will accept the token from the client and verify that this token is the **token of the viewer currently signed in to our app**. Later on, we'll _authorize_ this viewer to make requests for sensitive data.

Since this `authorize()` function will be used in potentially many different GraphQL resolvers, we'll create it in a `utils/index.ts` file kept within the `src/lib/` folder.

```shell
client/
  src/
    // ...
    lib/
      // ...
      utils
        index.ts
    // ...
  // ...
```

In the `src/lib/utils/index.ts` file, we'll export an `authorize()` function that is to accept the `db` object and the `req` object. We'll import the `Request` interface from `express` and the `Database` interface from our `src/lib/types.ts` file and set the `db` and `req` parameters with these types.

```tsx
import { Request } from "express";
import { Database } from "../types";

export const authorize = (db: Database, req: Request) => {};
```

We'll want this `authorize()` function to access the `users` collection and return a `user` that matches the `cookie` and `token` of the logged-in viewer. We'll import the `User` interface from the `src/lib/types.ts` file as well and state the return type of our function as a promise that when resolved will either return an instance of the `User` or `null`.

```tsx
import { Request } from "express";
import { Database, User } from "../types";

export const authorize = async (db: Database, req: Request): Promise<User | null> => {};
```

We're saying `null` instead of `undefined` since the [`findOne()`](https://docs.mongodb.com/manual/reference/method/db.collection.findOne/) function we'll use from Mongo will either return the intended document object or a `null` value. With that said, in our `authorize()` function, we'll use Mongos `findOne()` helper to help find one document from the `users` collection.

```tsx
import { Request } from "express";
import { Database, User } from "../types";

export const authorize = async (db: Database, req: Request): Promise<User | null> => {
  const viewer = await db.users.findOne();
};
```

The `findOne` function takes a query that finds one document that satisfies the query. We'll query for the document in which the document `_id` matches the value of the `viewer` cookie in our request - with which we can access in the `signedCookies` field of the passed in `req` object.

```tsx
import { Request } from "express";
import { Database, User } from "../types";

export const authorize = async (db: Database, req: Request): Promise<User | null> => {
  const viewer = await db.users.findOne({
    _id: req.signedCookies.viewer
  });
};
```

We'll also want to verify the `token` value of the document matches that of the request. Since `token` is to be in the header passed in the request, we can get this value with the `req.get()` function and state the value of the header key, which we'll call `X-CSRF-TOKEN`. We'll then have the `authorize()` function return the document that has been potentially found.

```ts
import { Request } from "express";
import { Database, User } from "../types";

export const authorize = async (db: Database, req: Request): Promise<User | null> => {
  const token = req.get("X-CSRF-TOKEN");
  const viewer = await db.users.findOne({
    _id: req.signedCookies.viewer,
    token
  });

  return viewer;
};
```

That's all we'll do in the server project for now. We'll use this `authorize()` function in the upcoming resolvers we'll create to authorize the request to see if the intended viewer is making it and if so - return the `viewer` object. We'll now head to our client project and look to see how we can pass the `X-CSRF-TOKEN` as part of our requests.

### `X-CSRF-TOKEN`

We’re interested in having the client send the viewer token on every request so the server can receive that token as part of the request header and authorize that the request is coming from a signed-in user. In the `ApolloClient` constructor of our `apollo-boost` setting, there exists a `request` configuration option which is called on every request and where we can set `headers` as part of the context of our operation.

Let's see how this can work. In the `ApolloClient` constructor in the `src/index.tsx` file of our client project, we'll specify the `request` configuration option.

```tsx
const client = new ApolloClient({
  uri: "/api",
  request: () => {}
});
```

The `request` configuration function is an asynchronous function that receives the GraphQL operation.

```tsx
const client = new ApolloClient({
  uri: "/api",
  request: async operation => {}
});
```

We'll use the `operation` object and run the `setContext()` function available in `operation` and pass the options it can accept. We'll declare the `headers` option and specify the `X-CSRF-TOKEN` header we want to pass.

```tsx
const client = new ApolloClient({
  uri: "/api",
  request: async operation => {
    operation.setContext({
      headers: {
        "X-CSRF-TOKEN":
      }
    });
  }
});
```

Here's where we have a small issue. The `token` is part of the `viewer` state object and is set after the user is signed in. Our `ApolloClient` configuration is unaware of the `viewer` state object because it's created/defined outside of the context of our React application.

What we'll do is have the `token` as part of our client's `sessionStorage` and retrieve the token here from `sessionStorage`. If the token is available from `sessionStorage`, we'll pass it in as part of our header. If it isn't, we'll simply pass an empty string to ensure a string value is being passed.

With these changes, our `ApolloClient` constructor will appear as follows:

```tsx
const client = new ApolloClient({
  uri: "/api",
  request: async operation => {
    const token = sessionStorage.getItem("token");
    operation.setContext({
      headers: {
        "X-CSRF-TOKEN": token || ""
      }
    });
  }
});
```

> Above, we're using the double pipe operator as the logical OR operator to say we'll pass the token from session storage OR an empty string if it doesn't exist.

`sessionStorage` is the ideal storage mechanism here since data in `sessionStorage` is not automatically sent to our server unlike our cookie and we want our token to be part of the request header as _another_ alternative verification step. However, we'll now need to ensure the `token` is available in `sessionStorage` when a user logs-in, and is cleared from `sessionStorage` when a user logs-out.

First, when we successfully log-in with a cookie in the `<App />` component, we'll set our token in `sessionStorage`. If the log-in is unsuccessful (i.e. the request is complete but no token exists), we'll also go ahead clear the existing token from our `sessionStorage` to be on the safe side and ensure no token exists as part of `sessionStorage` in the case a user can't log in with a cookie. We'll update the `onCompleted()` callback of our `useMutation` Hook in the `<App />` component to reflect this.

```tsx
const App = () => {
  // ...
  const [logIn, { error }] = useMutation<LogInData, LogInVariables>(LOG_IN, {
    onCompleted: data => {
      if (data && data.logIn) {
        setViewer(data.logIn);

        if (data.logIn.token) {
          sessionStorage.setItem("token", data.logIn.token);
        } else {
          sessionStorage.removeItem("token");
        }
      }
    }
  });

  // ...
};
```

We will also need to set the `token` data of `sessionStorage` when we log-in in from our `<Login />` component so we'll update the `onCompleted()` callback for the `useMutation` Hook used in the `<Login />` component.

```tsx
export const Login = ({ setViewer }: Props) => {
  // ...
  const [
    logIn,
    { data: logInData, loading: logInLoading, error: logInError }
  ] = useMutation<LogInData, LogInVariables>(LOG_IN, {
    onCompleted: data => {
      if (data && data.logIn && data.logIn.token) {
        setViewer(data.logIn);
        sessionStorage.setItem("token", data.logIn.token);
        displaySuccessNotification("You've successfully logged in!");
      }
    }
  });

  // ...
};
```

Finally, we'll need to remove the `token` data kept in `sessionStorage` when we log-out. To achieve this, we'll update the `onCompleted()` callback of the `logOut` mutation conducted in the `<MenuItems />` component.

```tsx
export const MenuItems = ({ viewer, setViewer }: Props) => {
  const [logOut] = useMutation<LogOutData>(LOG_OUT, {
    onCompleted: data => {
      if (data && data.logOut) {
        setViewer(data.logOut);
        sessionStorage.removeItem("token");
        displaySuccessNotification("You've successfully logged out!");
      }
    },
    onError: () => {
      // ...
    }
  });
};
```

That's all we'll do for now. For every request made in our app, the `X-CSRF-TOKEN` will now be passed to our server as a header property. In our server, when we run the `authorize()` function, we'll check to see if the viewer can be found with this token in our database. In resolver functions where we want to verify that the request is coming from a valid viewer, we'll obtain the `viewer` information from the `authorize()` function and allow the request to query or manipulate sensitive information in our app.
